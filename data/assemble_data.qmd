---
title: "Assemble a dataset for analysis"
author: "Maxime Fraser Franco"
date: "January 9, 2024"
toc: true
number-sections: true
format:
  html
#execute:
#  warning: false
---

## Description

In this notebook, I show the pipeline to assemble a synthetic dataset that I will use to produce the analyses for the manuscript.

## Import the data from GitHub

The data is hosted on a GitHub repository that you can access [here](https://github.com/quantitative-ecologist/experience-hunting-tactics).

### Original dataset

Here, I import the original dataset used in Fraser Franco et al. (2024).

```{r}
library(data.table)

github_id <- "https://raw.githubusercontent.com/quantitative-ecologist/"
repo <- "experience-hunting-tactics"
file1 <- "/main/data/FraserFrancoetal2023-data.csv"
dat1 <- fread(
  file.path(github_id, repo, file1),
  stringsAsFactors = TRUE
)
```

Check the data structure

```{r}
knitr::kable(head(dat1))
```

### Predicted data

Next, I import predicted values of foraging behaviour generated from a Bayesian multivariate double-hierarchical model. These predictions allow us to assess whether predators were specialist or flexible hunters across experience. The predictions are saved as an `.rds` file.

```{r}
file2 <- "/main/outputs/03_outputs_model-processing/DHMLM_id-draws.rds"
raw_url <- paste0(github_id, repo, file2)
dat2 <- readRDS(url(raw_url))

# Columns as factors
cols <- c("xp_level", "predator_id", "variable")
dat2[
  ,
  (cols) := lapply(.SD, as.factor),
  .SDcols = (cols)
]
```

Check the data structure

```{r}
knitr::kable(head(dat2))
```

#### Classify predators into hunting types

Based on the results of the model, we will now assign a hunting type to every predator at each experience level.

**The predator's tactic**

The tactic is defined along an ambush-cursorial continuum using the predator's speed as a proxy. For details, see [Fraser Franco et al. (2022)](https://academic.oup.com/beheco/article/33/5/967/6628566?login=false).

The tactic can be:  

1. Ambush
2. Intercepting
3. Cursorial

**The foraging strategy**

The predator's foraging strategy is based the predicted values of sigma speed. Lower values of sigma indicate a narrower behavioural distribution, while higher values indicate a wider distribution. The strategy is defined along a specialized-flexible continuum.

In Fraser Franco et al. (2024), we found that the predator's tactic and foraging strategy are negatively correlated, indicating that faster (cursorial) predators are more specialized, while slower (ambush) predators are more flexible.

The strategy can be:  

1. Specialized
2. Intermediate
3. Flexible

Here, we combine both information to classify predators into hunting types. This will make it easier to compute the joint probability distribution of the Bayesian learning network. I classify predators using fuzzy c-means clustering using the function `fanny()` from the `cluster` package.

```{r}
library(cluster)
library(factoextra)

# Function to perform fanny clustering with a fixed seed
fanny_clustering <- function(data, k, seed, maxit) {
  set.seed(seed)
  result <- fanny(
    data, k = k,
    maxit = maxit, stand = FALSE
  )
  return(result)
}

# Sample data for three xp levels
nov <- dat2[xp_level == "novice", c(3, 4)]
interm <- dat2[xp_level == "interm", c(3, 4)]
adv <- dat2[xp_level == "advanced", c(3, 4)]

# Perform fanny clustering for each timeframe with a fixed seed
seed <- 123
k <- 3
maxit <- 500
clust1 <- fanny_clustering(nov, k, seed, maxit)
clust2 <- fanny_clustering(interm, k, seed, maxit)
clust3 <- fanny_clustering(adv, k, seed ,maxit)

fviz_cluster(
    clust1, ellipse.type = "norm", repel = TRUE,
    palette = "jco", ggtheme = theme_classic(),
    legend = "top", geom = "point",
    xlab = "\nPredicted mean speed",
    ylab = "Predicted IIV in speed\n",
    pointsize = 2
) +
scale_y_continuous(
    breaks = seq(-4, 4, 2),
    limits = c(-5, 4.3)
) +
scale_x_continuous(
    breaks = seq(-4, 4, 2),
    limits = c(-5, 4)
) +
ggtitle("Clustering of novice predators") +
theme_classic(base_size = 15)

fviz_cluster(
    clust2, ellipse.type = "norm", repel = TRUE,
    palette = "jco", ggtheme = theme_classic(),
    legend = "top", geom = "point",
    xlab = "\nPredicted mean speed",
    ylab = "Predicted IIV in speed\n",
    pointsize = 2
) +
scale_y_continuous(
    breaks = seq(-4, 4, 2),
    limits = c(-4, 4.3)
) +
scale_x_continuous(
    breaks = seq(-5.1, 4, 2),
    limits = c(-5.1, 4)
) +
ggtitle("Clustering of intermediate predators") +
theme_classic(base_size = 15)

fviz_cluster(
    clust3, ellipse.type = "norm", repel = TRUE,
    palette = "jco", ggtheme = theme_classic(),
    legend = "top", geom = "point",
    xlab = "\nPredicted mean speed",
    ylab = "Predicted IIV in speed\n",
    pointsize = 2
) +
scale_y_continuous(
    breaks = seq(-4, 4, 2),
    limits = c(-4.8, 4.3)
) +
scale_x_continuous(
    breaks = seq(-4, 4, 2),
    limits = c(-4.8, 4)
) +
ggtitle("Clustering of advanced predators") +
theme_classic(base_size = 15)






# Verify the goodness of clustering results
fviz_silhouette(
    clust1, palette = "jco",
    ggtheme = theme_classic()
)
```





#### Add the information to the predicted dataset

First, I need to extract the clustering results for every experience level.

```{r}
# List of fuzzy clustering objects
clust_list <- list(clust1, clust2, clust3)

# XP levels
xp_levels <- factor(c("novice", "interm", "advanced"))

# Initialize an empty list to store the results
result_list <- list()

# Loop through the clustering objects and create data.tables
for (i in seq_along(clust_list)) {
  result_list[[i]] <- data.table(
    strategy = clust_list[[i]]$clustering,
    predator_id = unique(dat2$predator_id),
    xp_level = xp_levels[i]
  )
}

# Combine into a single data.table
clusters <- rbindlist(result_list)
```

Second, I merge the results (`clusters`) with `dat2`.

```{r}
dat2 <- merge(
  dat2, clusters,
  by = c("predator_id", "xp_level")
)
```

Lastly, I rename the clustering results to reflect the strategy


```{r}

```




## Import variables from raw data

I include variables from the raw data that were missing in the original dataset. These variables relate to the predator's attacks.

```{r}
vars <- fread(
  file.path(getwd(), "chapter2-ogdat", "final-data.csv"),
  select = c(
    "match_id", "predator_id", "chase_count", "chase_count_success",
    "attacks_count", "prey_avg_heal_count", "prey_var_heal_count"),
  stringsAsFactors = TRUE
)

vars[, chase_success_ratio := chase_count_success / chase_count]
```

## Merge into one dataset

### Reshape the original data

Add a xp_level variable to dat1 to combine.

```{r}
# Experience column
dat1[cumul_xp_pred < 100,
     xp_level := "novice"]

dat1[cumul_xp_pred %between% c(100, 299),
     xp_level := "interm"]

dat1[cumul_xp_pred >= 300,
     xp_level := "advanced"]

dat1[, xp_level := as.factor(xp_level)]
```

### Reshape the predicted data

Here, I reshape the data to wide format so it is easier to work with when I merge.

First, I select the variables I need.

```{r}
dat2 <- unique(
    dat2[
        variable == "pred_speed",
        .(predator_id, xp_level, variable, sigma, mean_estimated)
    ]
)
```

Second, I reshape the table to wide format

```{r}
dat2 <- dcast(
    dat2,
    predator_id + xp_level ~ sigma,
    value.var = "mean_estimated"
)

setnames(
    dat2,
    old = c("0", "1"),
    new = c("predicted_mean_speed", "predicted_sigma_speed")
)
```

Lastly, I add "pred" before each value of `predator_id` to have the same structure as `dat1`

```{r}
dat2[, predator_id := as.factor(paste0("pred", predator_id))]
```

Check the data

```{r}
knitr::kable(head(dat2))
```

### Merge the tables

```{r}
data <- merge(
    dat1,
    dat2,
    all.x = TRUE,
    by = c("predator_id", "xp_level")
)

data <- merge(
  data,
  vars,
  by = c("match_id", "predator_id")
)
```

## Organize the combined dataset

### Remove outlier

Remove predator outlier. This predator was removed from the analyses presented in Fraser Franco et al. (2024).

```{r}
data <- data[predator_id != "pred379433"]
data[, predator_id := factor(predator_id)]
```

Check the table

```{r}
knitr::kable(head(data))
```
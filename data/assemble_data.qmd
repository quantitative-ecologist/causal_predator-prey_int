---
title: "Assemble a dataset for analysis"
author: "Maxime Fraser Franco"
date: "January 9, 2024"
toc: true
number-sections: true
format:
  html
#execute:
#  warning: false
---

## Description

In this notebook, I build a pipeline that assembles a synthetic dataset that I will use for the analyses presented in the manuscript of this project. The pipeline is coded in `R`.

I start by importing the libraries that I will use.

```{r}
#| warnings: false
#| message: false
#| output: false

libs <- c(
  "data.table", "cluster",
  "ggplot2", "ggpubr", "viridis"
)
lapply(libs, library, character.only = TRUE)
```

## Import the data from GitHub

The data is hosted on a GitHub repository that you can access [here](https://github.com/quantitative-ecologist/experience-hunting-tactics).

### Original dataset

Here, I import the original dataset used in Fraser Franco et al. (2024).

```{r}
github_id <- "https://raw.githubusercontent.com/quantitative-ecologist/"
repo <- "experience-hunting-tactics"
file1 <- "/main/data/FraserFrancoetal2023-data.csv"
dat1 <- fread(
  file.path(github_id, repo, file1),
  stringsAsFactors = TRUE
)
```

Check the data structure

```{r}
knitr::kable(head(dat1))
```

### Predicted data

Next, I import predicted values of foraging behaviour generated from a Bayesian multivariate double-hierarchical model. These predictions allow us to assess whether predators were specialist or flexible hunters across experience. The predictions are saved as an `.rds` file.

```{r}
file2 <- "/main/outputs/03_outputs_model-processing/DHMLM_id-draws.rds"
raw_url <- paste0(github_id, repo, file2)
dat2 <- readRDS(url(raw_url))

# Columns as factors
cols <- c("xp_level", "predator_id", "variable")
dat2[
  ,
  (cols) := lapply(.SD, as.factor),
  .SDcols = (cols)
]
```

Check the data structure

```{r}
knitr::kable(head(dat2))
```

## Import variables from raw data

I include variables from the raw data that were missing in the original dataset. These variables relate to the predator's attacks.

```{r}
vars <- fread(
  file.path(getwd(), "chapter2-ogdat", "final-data.csv"),
  select = c(
    "match_id", "predator_id", "chase_count", "chase_count_success",
    "attacks_count", "prey_avg_heal_count", "prey_var_heal_count"),
  stringsAsFactors = TRUE
)

vars[, chase_success_ratio := chase_count_success / chase_count]
```

## Classify predators into hunting styles

Based on the predictions of the Bayesian multivariate hierarchical model (`dat2`), we will now assign a hunting type to every predator at each experience level.

**The predator's tactic**

The tactic is defined along an ambush-cursorial continuum using the predator's speed as a proxy. For details, see [Fraser Franco et al. (2022)](https://academic.oup.com/beheco/article/33/5/967/6628566?login=false).

The tactic can be:  

1. Ambush
2. Intercepting
3. Cursorial

**The foraging strategy**

The predator's foraging strategy is based the predicted values of sigma speed in `dat2`. This parameter is the variance of the behavioural distribution estimated for every predator. Lower values of sigma indicate a narrower behavioural distribution (specialization), while higher values indicate a wider distribution (flexibility). The strategy is defined along a specialized-flexible continuum.

The strategy can be:  

1. Specialized
2. Intermediate
3. Flexible

In Fraser Franco et al. (2024), we found that the predators' tactics and foraging strategies are negatively correlated, indicating that faster (cursorial) predators are more specialized, while slower (ambush) predators are more flexible.

Here, we combine both information to classify predators into hunting types. This will make it easier to compute the joint probability distribution of the Bayesian learning network. I classify predators using fuzzy c-means clustering with the `fanny()` function from the `cluster` package.

### Prepare the data for clustering

Here, I prepare `dat2` to have clean tables for clustering.

First, I calculate the posterior median of sigma values, since the median is a more robust central-tendency measure for non symmetric distributions such as variances. I also remove duplicate values to only keep the information on the median of the posterior. Lastly, I arrange the table into wide format.

```{r}
# Calculate the posterior median values
dat2[
  , post_median := median(value),
  by = .(xp_level, sigma, variable, predator_id)
]

# Keep unique values for speed only
dat2 <- unique(
    dat2[
        variable == "pred_speed",
        .(predator_id, xp_level, variable, sigma, post_median)
    ]
)

# Reshape the table to wide format
dat2 <- dcast(
    dat2,
    predator_id + xp_level ~ sigma,
    value.var = "post_median"
)

# Change column names to reflect the variable name
setnames(
    dat2,
    old = c("0", "1"),
    new = c("predicted_mean_speed", "predicted_sigma_speed")
)
```

I add "pred" before each label of `predator_id` to have the same structure as `dat1`. This will be useful when we merge the tables.

```{r}
dat2[, predator_id := as.factor(paste0("pred", predator_id))]
```

I now generate three tables from `dat2` for each experience level. These are the tables that I will use for the fuzzy clustering.

```{r}

# Sample data for three xp levels
filter_dat <- function(data, level) {
  result <- data[
    xp_level == level,
    c(3, 4)
  ]
  return(result)
}

nov <- filter_dat(dat2, level = "novice")
interm <- filter_dat(dat2, level = "interm")
adv <- filter_dat(dat2, level = "advanced")
```

### Run the fuzzy clustering algorithm

I now run the clustering algorithm on the three datasets `nov`, `interm`, and `adv`.

```{r}
# Function to perform fanny clustering with a fixed seed
fanny_clustering <- function(data, k, seed, maxit) {
  set.seed(seed)
  result <- fanny(
    data, k = k,
    maxit = maxit, stand = FALSE
  )
  return(result)
}

# Clustering parameters
seed <- 123
k <- 3
maxit <- 500

# Run clustering algorithm at each xp level
clust1 <- fanny_clustering(nov, k, seed, maxit)
clust2 <- fanny_clustering(interm, k, seed, maxit)
clust3 <- fanny_clustering(adv, k, seed ,maxit)
```

I plot the results to visualize the clusters. I start by preparing the clustering objects to use as data to feed the to the `ggplot()` function.

```{r, out.width="100%", out.height="70%"}
# Generate the data from the clustering objects
generate_dataset <- function(clust) {
  data.frame(
    cluster = clust$clustering,
    predicted_mean_speed = clust$data[, 1],
    predicted_sigma_speed = clust$data[, 2]
  )
}

# List of clustering objects from fanny()
fanny_objects <- list(clust1, clust2, clust3)

# Generate datasets and store in a list.
datasets <- lapply(fanny_objects, generate_dataset)
```

I then proceed to plot the results.

```{r, fig.height=4, fig.width=10}
# Function to generate ggplot2 plot
generate_plot <- function(cluster_data, title) {
  ggplot(
    data = cluster_data,
    aes(x = predicted_mean_speed,
        y = predicted_sigma_speed,
        color = as.factor(cluster))
    ) +
    geom_point(size = 2, alpha = 0.4) +
    stat_ellipse(
        geom = "path", level = 0.95,
        linetype = "solid",
        type = "norm"
    ) +
    scale_color_viridis(
        discrete = TRUE, option = "D",
        name = "Cluster:"
    ) +
    scale_x_continuous(
        breaks = seq(-1, 0.5, 0.25),
        limits = c(-1, 0.5)
    ) +
    scale_y_continuous(
        breaks = seq(-1, 2, 0.5),
        limits = c(-1, 2)
    ) +
    labs(
      x = "\nPredicted mean speed",
      y = "Predicted IIV in speed\n",
      title = title
    ) +
    theme_classic(base_size = 12) +
    theme(legend.position = "top")
}

# Plot titles for each panel
plot_titles <- c("Novice", "Intermediate", "Advanced")

# Generate ggplot2 plots using lapply
plots <- lapply(seq_along(datasets), function(i) {
  generate_plot(datasets[[i]], plot_titles[i])
})

# Display the plots
do.call(
    ggarrange,
    c(plots, nrow = 1, ncol = length(plots))
)
```

The results are very similar across experience levels. Strangely, the algorithm appears to switch the assignment of group 1 and 3 for when predators are advanced. I will need to take this into account when I assign the hunting type of the predators.

### Add the information to the predicted dataset

I will now add the clustering results to `dat2`, and then assign the hunting style for each predator based on the clusters.

First, I need to extract the clustering results for every experience level.

```{r}
# List of fuzzy clustering objects
clust_list <- list(clust1, clust2, clust3)

# XP levels
xp_levels <- factor(c("novice", "interm", "advanced"))

# Initialize an empty list to store the results
result_list <- list()

# Loop through the clustering objects and create data.tables
for (i in seq_along(clust_list)) {
  result_list[[i]] <- data.table(
    cluster = clust_list[[i]]$clustering,
    predator_id = unique(dat2$predator_id),
    xp_level = xp_levels[i]
  )
}

# Combine into a single data.table
clusters <- rbindlist(result_list)
```

Second, I merge the results (`clusters`) with `dat2`.

```{r}
dat2 <- merge(
  dat2, clusters,
  by = c("predator_id", "xp_level")
)
```

Lastly, I rename the clustering results to reflect the hunting type.

For novice and intermediate predators :  

- 1 = ambush-flexible
- 2 = cursorial-specialist
- 3 = intercepting-intermediate

For advanced predators :  

- 1 = intercepting-intermediate
- 2 = cursorial-specialist
- 3 = ambush-flexible

I start by computing the results for novice and intermediate predators.

```{r}
dat2[
  xp_level %in% c("novice", "interm") & cluster == 1,
  hunting_type := "ambush-flexible"
]

dat2[
  xp_level %in% c("novice", "interm") & cluster == 2,
  hunting_type := "cursorial-specialist"
]

dat2[
  xp_level %in% c("novice", "interm") & cluster == 3,
  hunting_type := "intercepting-intermediate"
]
```

Now for advanced predators.

```{r}
dat2[
  xp_level == "advanced" & cluster == 1,
  hunting_type := "intercepting-intermediate"
]

dat2[
  xp_level == "advanced" & cluster == 2,
  hunting_type := "cursorial-specialist"
]

dat2[
  xp_level == "advanced" & cluster == 3,
  hunting_type := "ambush-flexible"
]

dat2[, hunting_type := as.factor(hunting_type)]
```

## Merge into one dataset

### Reshape the original data

Add a xp_level variable to `dat1` to merge with `dat2`.

```{r}
# Experience column
dat1[cumul_xp_pred < 100,
     xp_level := "novice"]

dat1[cumul_xp_pred %between% c(100, 299),
     xp_level := "interm"]

dat1[cumul_xp_pred >= 300,
     xp_level := "advanced"]

dat1[, xp_level := as.factor(xp_level)]
```

### Merge the tables

First, I merge `dat1` with `dat2`, creating the `data` object.

```{r}
data <- merge(
    dat1,
    dat2,
    all.x = TRUE,
    by = c("predator_id", "xp_level")
)
```

Second, I merge the attack variables (`vars`) that we exported earlier to the new `data` object.

```{r}
data <- merge(
  data,
  vars,
  by = c("match_id", "predator_id")
)
```

## Final steps

### Remove outlier

Remove a predator outlier. This predator was removed from the analyses presented in Fraser Franco et al. (2024).

```{r}
data <- data[predator_id != "pred379433"]
data[, predator_id := factor(predator_id)]
```

Check the table

```{r}
knitr::kable(head(data))
```

### Compute variables

#### Prior prey behaviours

Here for each predator ID, I will create new columns that are the behaviours of the prey that were observed in the match before. This will be used as a variable in the model to see the effect of the prey encountered before, in contrast with the behaviour of the prey being hunted.

I start by ordering the dataset by predator ID and timestamp.

```{r}
data <- data[order(predator_id, timestamp)]
```

Then I compute the prey variables in the match before

```{r}
newcols <- c(
  "prior_prey_speed",
  "prior_prey_heal",
  "prior_success"
)

data[
  , (newcols) := shift(
    .SD, type = "lag", n = 1
    )
  , by = predator_id
  , .SDcols = c(
    "prey_avg_speed",
    "prey_avg_heal_count",
    "hunting_success"
    )
]
```

Check the output if it worked

```{r}
knitr::kable(head(
  data[, .(
    timestamp, predator_id,
    prey_avg_speed, prior_prey_speed,
    prey_avg_heal_count, prior_prey_heal,
    hunting_success, prior_success
  )]
))
```

#### Time between observations

Here, I compute the time lag between each observation to know how long it took for each predator to play a new game.

The output is in minutes.

```{r}
data[, time_lag := c(NA, diff(timestamp)), by = predator_id]
```

Check if it worked

```{r}
knitr::kable(head(
  data[, .(
    timestamp, predator_id, time_lag
  )]
))
```

### Save the data

I can now save the full dataset as a .csv file.

```{r}
write.csv(
  data,
  file = "FraserFranco-etal-XXXX.csv",
  row.names = FALSE)
```